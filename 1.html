<!-- What is a Temporal Dead Zone? -->
The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring a variable with 
the let and const keywords, but not with var. In ECMAScript 6, accessing a let or const variable 
before its declaration (within its scope) causes a ReferenceError. 
The time span when that happens, between
the creation of a variableâ€™s binding and its declaration, is called the temporal dead zone.
ex - function somemethod() {
    console.log(counter1); 
    console.log(counter2); 
    var counter1 = 1;
    let counter2 = 2;
{  

<!-- What is the for-in loop in JavaScript? Give its syntax -->
The for-in loop is a special type of a loop that iterates over the properties of an object, 
or the elements of an array. for - in loop : returns you the indexes of the arrayThe generic 
syntax of the for-in loop is:
ex - for(variable in object) {
}	

<!-- Explain Local Scope, Block Scope, Functional Scope and Scope Chain in javascript -->
Block scope:- Variables declared inside a { } block cannot be accessed from outside the block:
ex - {
    let x = 2;
  }
Local scope: - Variables declared within a JavaScript function, become LOCAL to the function.
ex - function myFunction() {
    let carName = "Volvo";
  }
Functional scope:- Variables declared with var, let and const are quite similar when declared 
inside a function.
ex - function myFunction() {
    var carName = "Volvo"; 
  }
Scope chain:-Scope chain: Whenever our code tries to access a variable during the function call,
it starts the searching from local variables. And if the variable is not found, it'll continue
searching in its outer scope or parent functions' scope until it reaches the global scope 
and completes searching for the variable there.

<!-- What is difference between null and undefined and where to use what? -->
undefined- It means a variable has been declared but has not yet been assigned a value.
var testVar; alert(testVar); 
alert(typeof testVar);
null:- It is an assignment value. It can be assigned to a variable as a representation of no 
value:
var testVar = null; alert(testVar); 
alert(typeof testVar); 

<!-- what is Symbol? -->
Symbols are new primitive type introduced in ES6. Symbols are completely unique identifiers.
Just like their primitive counterparts (Number, String, Boolean), they can be created using 
the factory function Symbol() which returns a Symbol.

<!-- Write code to explain map and filter in arrays -->
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(item => item * 2);
console.log(doubled); 
var numbers = [1,2,3,4,5];
var greaterThan2 = numbers.filter(n => n > 2);
greaterThan2; 

<!-- Explain passed by value and passed by reference -->
Pass By Value: In Pass by value, function is called by directly passing the value of the 
variable as an argument. So any changes made inside the function does not affect the original 
value.
ex - function Passbyvalue(a, b) {
    let tmp;
    tmp = b;
    b = a;
    a = tmp;
    console.log(`Inside Pass by value function -> a = ${a} b = ${b}`);
}
let a = 1;
let b = 2;
console.log(`Before calling Pass by value 
        Function -> a = ${a} b = ${b}`);
  
Passbyvalue(a, b); 
console.log(`After calling Pass by value  Function -> a =${a} b = ${b}`);

Pass by Reference: In Pass by Reference, Function is called by directly passing the reference/
address of the variable as an argument. So changing the value inside the function also change
the original value. In JavaScript array and Object follows pass by reference property.
ex - unction PassbyReference(obj) {
    let tmp = obj.a;
    obj.a = obj.b;
    obj.b = tmp;
  
    console.log(`Inside Pass By Reference 
        Function -> a = ${obj.a} b = ${obj.b}`);
}
  
let obj = {
    a: 10,
    b: 20
  
}
console.log(`Before calling Pass By Reference 
    Function -> a = ${obj.a} b = ${obj.b}`);
PassbyReference(obj)
console.log(`After calling Pass By Reference 
    Function -> a = ${obj.a} b = ${obj.b}`);

<!-- Please explain Self Invoking Function and its code -->
A self-invoking expression is invoked (started) automatically, without being called.
Function expressions will execute automatically if the expression is followed by ().
ex-(function () {
    let x = "Hello!!"; 
  })();
  








  
 
  


